(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{535:function(a,s,t){"use strict";t.r(s);var e=t(20),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"_4-类、对象和方法介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-类、对象和方法介绍"}},[a._v("#")]),a._v(" 4 类、对象和方法介绍")]),a._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#类基础"}},[a._v("类基础")]),t("ul",[t("li",[t("a",{attrs:{href:"#类的一般形式"}},[a._v("类的一般形式")])]),t("li",[t("a",{attrs:{href:"#定义一个类"}},[a._v("定义一个类")])]),t("li",[t("a",{attrs:{href:"#对象是如何创建的"}},[a._v("对象是如何创建的")])]),t("li",[t("a",{attrs:{href:"#引用变量和赋值"}},[a._v("引用变量和赋值")])])])]),t("li",[t("a",{attrs:{href:"#方法"}},[a._v("方法")]),t("ul",[t("li",[t("a",{attrs:{href:"#从方法中返回"}},[a._v("从方法中返回")])]),t("li",[t("a",{attrs:{href:"#构造函数"}},[a._v("构造函数")])])])]),t("li",[t("a",{attrs:{href:"#重新审视new"}},[a._v("重新审视new")])]),t("li",[t("a",{attrs:{href:"#垃圾收集"}},[a._v("垃圾收集")])]),t("li",[t("a",{attrs:{href:"#this"}},[a._v("this")])])])]),t("p"),a._v(" "),t("p",[a._v("类是Java的精髓。整个Java语言是在类的基础上构建的，因为类定义了一个对象的本质。因此，类构成了Java中面向对象编程的基础。在一个类中，有定义的数据和对数据进行的操作（方法）。")]),a._v(" "),t("h2",{attrs:{id:"类基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类基础"}},[a._v("#")]),a._v(" 类基础")]),a._v(" "),t("p",[a._v("类是定义对象的一个模板。它定义了数据和对数据的相关操作。Java使用类来构造对象。对象是类的实例。关键要明确一点: 类是抽象的。先有类，再有对象。")]),a._v(" "),t("p",[a._v("另一点要明确的是: 组成一个类的方法和变量叫做一个类的"),t("em",[a._v("成员")]),a._v("。这些数据成员也被称为 "),t("em",[a._v("实例变量")]),a._v(".")]),a._v(" "),t("h3",{attrs:{id:"类的一般形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的一般形式"}},[a._v("#")]),a._v(" 类的一般形式")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("class classname {\n    // declare instance variables\n    type var1;\n    type var2;\n    // ...\n    type varN;\n\n    // declare methods\n    type method1(parameters) {\n     // body of method\n    }\n    type method2(parameters) {\n     // body of method\n    }\n    // ...\n    type methodN(parameters) {\n     // body of method\n    }\n}\n")])])]),t("blockquote",[t("p",[a._v("注: 一般情况下，对于一个逻辑实体定义一个类，且只定义一个类。")])]),a._v(" "),t("h3",{attrs:{id:"定义一个类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义一个类"}},[a._v("#")]),a._v(" 定义一个类")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Vehicle")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" passengers"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// number of passengers")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" fuelcap"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// fuel capacity in gallons")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" mpg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// fuel consumption in miles per gallon")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("定义一个类，就创建了一个新的类型。在上面的例子中，我们创建了一个新的类型——Vehicle.")]),a._v(" "),t("p",[a._v("创建Vehicle对象:")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Vehicle")]),a._v(" minivan "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Vehicle")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("访问成员:")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("minivam"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("fuelcap "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("h3",{attrs:{id:"对象是如何创建的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象是如何创建的"}},[a._v("#")]),a._v(" 对象是如何创建的")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Vehicle")]),a._v(" minivan "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Vehicle")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("上面的语句执行了两个函数。首先，声明了一个类型为 Vehicle 的变量 minivan。这个变量没有定义对象。相反，它只是一个能够的指向该对象的变量。其次，声明语句创建了一个对象的实例，并且将对象的引用赋给了 minivan。这是通过new 运算符完成的。")]),a._v(" "),t("p",[a._v("new 运算符动态的为对象分配内存，并返回该对象的引用。这个引用，就是对象在内存中的地址。然后，这个引用存储在一个变量中。因此，在Java中，所有类的对象必须动态分配。")]),a._v(" "),t("p",[a._v("将这两拆分开，就是:")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Vehicle")]),a._v(" minivam"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 定义对象的引用")]),a._v("\nminivan "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Vehicle")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 分配一个Vehicle对象")]),a._v("\n")])])]),t("h3",{attrs:{id:"引用变量和赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用变量和赋值"}},[a._v("#")]),a._v(" 引用变量和赋值")]),a._v(" "),t("p",[a._v("在复制操作中，对象的引用变量的行为与原始类型变量的行为不同。")]),a._v(" "),t("p",[a._v("对于原始类型变量，赋值操作是值传递。")]),a._v(" "),t("p",[a._v("对于引用类型的变量，赋值操作是引用传递。")]),a._v(" "),t("h2",{attrs:{id:"方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),t("p",[a._v("上面提到，实例变量和方法构成了类。方法一般定义了对于数据的操作，一般形式如下:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("ret-type name( parameter-list ) {\n    // body of method\n}\n")])])]),t("h3",{attrs:{id:"从方法中返回"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从方法中返回"}},[a._v("#")]),a._v(" 从方法中返回")]),a._v(" "),t("p",[a._v("通常，有两种情况会导致方法返回。一种是, 方法执行完了； 一种是，执行了 return 语句。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// or")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// return void")]),a._v("\n")])])]),t("h3",{attrs:{id:"构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[a._v("#")]),a._v(" 构造函数")]),a._v(" "),t("p",[a._v("构造函数用于在对象创建时对其进行初始化。它有以下特点/规定:")]),a._v(" "),t("ul",[t("li",[a._v("名称和类名相同")]),a._v(" "),t("li",[a._v("没有返回类型")])]),a._v(" "),t("p",[a._v("所有类都有构造函数，无论你是否定义了构造函数，因为Java会自动提供一个默认的无参构造函数。在这种情况下，非初始化的成员变量都有一个默认值，它们是 0 ， null 和 false ， 分配对应 数值型，引用类型 和 布尔类型变量。要是你定义了自己的构造函数，那么就不会生成默认的无参构造函数了。")]),a._v(" "),t("h2",{attrs:{id:"重新审视new"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重新审视new"}},[a._v("#")]),a._v(" 重新审视new")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("class-var = new class-name(arg-list);\n")])])]),t("p",[a._v("class-var 是一个要创建的类型的变量，class-name是要初始化的类。如果类没有定义自己的构造函数，那么new会使用Java提供的默认的无参构造。因此，new 可以用来创建任意类型的对象。new 返回新创建的对象的引用，该引用被赋值给 class-var。")]),a._v(" "),t("p",[a._v("由于内存是有限的，可能由于内存不足，new无法为对象分配内存。如果出现这种情况，就会出现运行时错误。")]),a._v(" "),t("h2",{attrs:{id:"垃圾收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集"}},[a._v("#")]),a._v(" 垃圾收集")]),a._v(" "),t("p",[a._v("如上所述，通过new动态的从可用内存池中为对象分配内存。内存是有限的，可用内存可能会被耗尽。因此，new 操作可能会由于内存不足而失败。因此，一个动态分配方案的关键就是：从未使用的对象恢复可用内存，使得该内存可用于后续的重新分配。在一些编程语言中，以前分配的内存的释放是手动处理的。然而，Java使用了一种不同的、更省事的方法：垃圾收集。")]),a._v(" "),t("p",[a._v("Java的垃圾收集系统自动回收对象--在幕后透明地发生，不需要任何程序员干预。其工作流程是：当一个对象没有被任何一个变量引用时，该对象就被认为不再需要了，该对象所占用的内存被释放。这个回收的内存可以用于后续的分配。")]),a._v(" "),t("p",[a._v("垃圾收集只在你的程序执行过程中零星地发生。它不会仅仅因为存在一个或多个不再使用的对象而发生。为了提高效率，垃圾收集器通常只在满足两个条件时运行：有对象要回收，有理由要回收。记住，垃圾回收需要时间，所以Java运行时系统只在适当的时候才进行垃圾回收。因此，你不可能精确地知道什么时候会进行垃圾回收")]),a._v(" "),t("h2",{attrs:{id:"this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[a._v("#")]),a._v(" this")]),a._v(" "),t("p",[a._v("当一个方法被调用时，会隐式地传递一个对象（即方法被调用的对象）的引用给它。这个引用叫做 this.")])])}),[],!1,null,null,null);s.default=n.exports}}]);