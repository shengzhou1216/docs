(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{558:function(e,a,v){"use strict";v.r(a);var t=v(20),n=Object(t.a)({},(function(){var e=this,a=e.$createElement,v=e._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"比较运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#比较运算符"}},[e._v("#")]),e._v(" 比较运算符")]),e._v(" "),v("p",[e._v("比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("2 > 1 // true\n")])])]),v("p",[e._v("上面代码比较"),v("code",[e._v("2")]),e._v("是否大于"),v("code",[e._v("1")]),e._v("，返回"),v("code",[e._v("true")]),e._v("。")]),e._v(" "),v("blockquote",[v("p",[e._v("注意，比较运算符可以比较各种类型的值，不仅仅是数值。")])]),e._v(" "),v("p",[e._v("JavaScript 一共提供了8个比较运算符。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v(">")]),e._v(" 大于运算符")]),e._v(" "),v("li",[v("code",[e._v("<")]),e._v(" 小于运算符")]),e._v(" "),v("li",[v("code",[e._v("<=")]),e._v(" 小于或等于运算符")]),e._v(" "),v("li",[v("code",[e._v(">=")]),e._v(" 大于或等于运算符")]),e._v(" "),v("li",[v("code",[e._v("==")]),e._v(" 相等运算符")]),e._v(" "),v("li",[v("code",[e._v("===")]),e._v(" 严格相等运算符")]),e._v(" "),v("li",[v("code",[e._v("!=")]),e._v(" 不相等运算符")]),e._v(" "),v("li",[v("code",[e._v("!==")]),e._v(" 严格不相等运算符")])]),e._v(" "),v("p",[e._v("这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。")]),e._v(" "),v("h2",{attrs:{id:"非相等运算符-字符串的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非相等运算符-字符串的比较"}},[e._v("#")]),e._v(" 非相等运算符：字符串的比较")]),e._v(" "),v("p",[e._v("字符串按照字典顺序进行比较。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("'cat' > 'dog' // false\n'cat' > 'catalog' // false\n")])])]),v("p",[e._v("JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("'cat' > 'Cat' // true'\n")])])]),v("p",[e._v("上面代码中，小写的"),v("code",[e._v("c")]),e._v("的 Unicode 码点（"),v("code",[e._v("99")]),e._v("）大于大写的"),v("code",[e._v("C")]),e._v("的 Unicode 码点（"),v("code",[e._v("67")]),e._v("），所以返回"),v("code",[e._v("true")]),e._v("。")]),e._v(" "),v("p",[e._v("由于所有字符都有 Unicode 码点，因此汉字也可以比较。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("'大' > '小' // false\n")])])]),v("p",[e._v("上面代码中，“大”的 Unicode 码点是22823，“小”是23567，因此返回"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"非相等运算符-非字符串的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非相等运算符-非字符串的比较"}},[e._v("#")]),e._v(" 非相等运算符：非字符串的比较")]),e._v(" "),v("p",[e._v("如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。")]),e._v(" "),v("p",[v("strong",[e._v("（1）原始类型值")])]),e._v(" "),v("p",[e._v("如果两个运算子都是原始类型的值，则是先转成数值再比较。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("5 > '4' // true\n// 等同于 5 > Number('4')\n// 即 5 > 4\n\ntrue > false // true\n// 等同于 Number(true) > Number(false)\n// 即 1 > 0\n\n2 > true // true\n// 等同于 2 > Number(true)\n// 即 2 > 1\n")])])]),v("p",[e._v("上面代码中，字符串和布尔值都会先转成数值，再进行比较。")]),e._v(" "),v("p",[v("strong",[e._v("这里需要注意与"),v("code",[e._v("NaN")]),e._v("的比较。任何值（包括"),v("code",[e._v("NaN")]),e._v("本身）与"),v("code",[e._v("NaN")]),e._v("使用非相等运算符进行比较，返回的都是"),v("code",[e._v("false")]),e._v("。")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("1 > NaN // false\n1 <= NaN // false\n'1' > NaN // false\n'1' <= NaN // false\nNaN > NaN // false\nNaN <= NaN // false\n")])])]),v("p",[v("strong",[e._v("（2）对象")])]),e._v(" "),v("p",[e._v("如果运算子是对象，会转为原始类型的值，再进行比较。")]),e._v(" "),v("p",[e._v("对象转换成原始类型的值，算法是先调用"),v("code",[e._v("valueOf")]),e._v("方法；如果返回的还是对象，再接着调用"),v("code",[e._v("toString")]),e._v("方法，详细解释参见《数据类型的转换》一章。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var x = [2];\nx > '11' // true\n// 等同于 [2].valueOf().toString() > '11'\n// 即 '2' > '11'\n\nx.valueOf = function () { return '1' };\nx > '11' // false\n// 等同于 [2].valueOf() > '11'\n// 即 '1' > '11'\n")])])]),v("p",[e._v("两个对象之间的比较也是如此。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("[2] > [1] // true\n// 等同于 [2].valueOf().toString() > [1].valueOf().toString()\n// 即 '2' > '1'\n\n[2] > [11] // true\n// 等同于 [2].valueOf().toString() > [11].valueOf().toString()\n// 即 '2' > '11'\n\n{ x: 2 } >= { x: 1 } // true\n// 等同于 { x: 2 }.valueOf().toString() >= { x: 1 }.valueOf().toString()\n// 即 '[object Object]' >= '[object Object]'\n")])])]),v("h2",{attrs:{id:"严格相等运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#严格相等运算符"}},[e._v("#")]),e._v(" 严格相等运算符")]),e._v(" "),v("p",[e._v("JavaScript 提供两种相等运算符："),v("code",[e._v("==")]),e._v("和"),v("code",[e._v("===")]),e._v("。")]),e._v(" "),v("p",[e._v("简单说，它们的区别是相等运算符（"),v("code",[e._v("==")]),e._v("）比较两个值是否相等，严格相等运算符（"),v("code",[e._v("===")]),e._v("）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（"),v("code",[e._v("===")]),e._v("）直接返回"),v("code",[e._v("false")]),e._v("，而相等运算符（"),v("code",[e._v("==")]),e._v("）会将它们转换成同一个类型，再用严格相等运算符进行比较。")]),e._v(" "),v("p",[e._v("本节介绍严格相等运算符的算法。")]),e._v(" "),v("p",[v("strong",[e._v("（1）不同类型的值")])]),e._v(" "),v("p",[e._v("如果两个值的类型不同，直接返回"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('1 === "1" // false\ntrue === "true" // false\n')])])]),v("p",[e._v("上面代码比较数值的"),v("code",[e._v("1")]),e._v("与字符串的“1”、布尔值的"),v("code",[e._v("true")]),e._v("与字符串"),v("code",[e._v('"true"')]),e._v("，因为类型不同，结果都是"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("p",[v("strong",[e._v("（2）同一类的原始类型值")])]),e._v(" "),v("p",[e._v("同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回"),v("code",[e._v("true")]),e._v("，值不同就返回"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("1 === 0x1 // true\n")])])]),v("p",[e._v("上面代码比较十进制的"),v("code",[e._v("1")]),e._v("与十六进制的"),v("code",[e._v("1")]),e._v("，因为类型和值都相同，返回"),v("code",[e._v("true")]),e._v("。")]),e._v(" "),v("p",[e._v("需要注意的是，"),v("code",[e._v("NaN")]),e._v("与任何值都不相等（包括自身）。另外，正"),v("code",[e._v("0")]),e._v("等于负"),v("code",[e._v("0")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("NaN === NaN  // false\n+0 === -0 // true\n")])])]),v("p",[v("strong",[e._v("（3）复合类型值")])]),e._v(" "),v("p",[e._v("两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("{} === {} // false\n[] === [] // false\n(function () {} === function () {}) // false\n")])])]),v("p",[e._v("上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("p",[e._v("如果两个变量引用同一个对象，则它们相等。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var v1 = {};\nvar v2 = v1;\nv1 === v2 // true\n")])])]),v("p",[e._v("注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var obj1 = {};\nvar obj2 = {};\n\nobj1 > obj2 // false\nobj1 < obj2 // false\nobj1 === obj2 // false\n")])])]),v("p",[e._v("上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("p",[v("strong",[e._v("（4）undefined 和 null")])]),e._v(" "),v("p",[v("code",[e._v("undefined")]),e._v("和"),v("code",[e._v("null")]),e._v("与自身严格相等。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("undefined === undefined // true\nnull === null // true\n")])])]),v("p",[e._v("由于变量声明后默认值是"),v("code",[e._v("undefined")]),e._v("，因此两个只声明未赋值的变量是相等的。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var v1;\nvar v2;\nv1 === v2 // true\n")])])]),v("h2",{attrs:{id:"严格不相等运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#严格不相等运算符"}},[e._v("#")]),e._v(" 严格不相等运算符")]),e._v(" "),v("p",[e._v("严格相等运算符有一个对应的“严格不相等运算符”（"),v("code",[e._v("!==")]),e._v("），它的算法就是先求严格相等运算符的结果，然后返回相反值。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("1 !== '1' // true\n// 等同于\n!(1 === '1')\n")])])]),v("p",[e._v("上面代码中，感叹号"),v("code",[e._v("!")]),e._v("是求出后面表达式的相反值。")]),e._v(" "),v("h2",{attrs:{id:"相等运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相等运算符"}},[e._v("#")]),e._v(" 相等运算符")]),e._v(" "),v("p",[e._v("相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("1 == 1.0\n// 等同于\n1 === 1.0\n")])])]),v("p",[e._v("比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成几种情况，讨论不同类型的值互相比较的规则。")]),e._v(" "),v("p",[v("strong",[e._v("（1）原始类型值")])]),e._v(" "),v("p",[e._v("原始类型的值会转换成数值再进行比较。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("1 == true // true\n// 等同于 1 === Number(true)\n\n0 == false // true\n// 等同于 0 === Number(false)\n\n2 == true // false\n// 等同于 2 === Number(true)\n\n2 == false // false\n// 等同于 2 === Number(false)\n\n'true' == true // false\n// 等同于 Number('true') === Number(true)\n// 等同于 NaN === 1\n\n'' == 0 // true\n// 等同于 Number('') === 0\n// 等同于 0 === 0\n\n'' == false  // true\n// 等同于 Number('') === Number(false)\n// 等同于 0 === 0\n\n'1' == true  // true\n// 等同于 Number('1') === Number(true)\n// 等同于 1 === 1\n\n'\\n  123  \\t' == 123 // true\n// 因为字符串转为数字时，省略前置和后置的空格\n")])])]),v("p",[e._v("上面代码将字符串和布尔值都转为数值，然后再进行比较。具体的字符串与布尔值的类型转换规则，参见《数据类型转换》一章。")]),e._v(" "),v("p",[v("strong",[e._v("（2）对象与原始类型值比较")])]),e._v(" "),v("p",[e._v("对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。")]),e._v(" "),v("p",[e._v("具体来说，先调用对象的"),v("code",[e._v("valueOf()")]),e._v("方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用"),v("code",[e._v("toString()")]),e._v("方法，得到字符串形式，再进行比较。")]),e._v(" "),v("p",[e._v("下面是数组与原始类型值比较的例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 数组与数值的比较\n[1] == 1 // true\n\n// 数组与字符串的比较\n[1] == '1' // true\n[1, 2] == '1,2' // true\n\n// 对象与布尔值的比较\n[1] == true // true\n[2] == true // false\n")])])]),v("p",[e._v("上面例子中，JavaScript 引擎会先对数组"),v("code",[e._v("[1]")]),e._v("调用数组的"),v("code",[e._v("valueOf()")]),e._v("方法，由于返回的还是一个数组，所以会接着调用数组的"),v("code",[e._v("toString()")]),e._v("方法，得到字符串形式，再按照上一小节的规则进行比较。")]),e._v(" "),v("p",[e._v("下面是一个更直接的例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("const obj = {\n  valueOf: function () {\n    console.log('执行 valueOf()');\n    return obj;\n  },\n  toString: function () {\n    console.log('执行 toString()');\n    return 'foo';\n  }\n};\n\nobj == 'foo'\n// 执行 valueOf()\n// 执行 toString()\n// true\n")])])]),v("p",[e._v("上面例子中，"),v("code",[e._v("obj")]),e._v("是一个自定义了"),v("code",[e._v("valueOf()")]),e._v("和"),v("code",[e._v("toString()")]),e._v("方法的对象。这个对象与字符串"),v("code",[e._v("'foo'")]),e._v("进行比较时，会依次调用"),v("code",[e._v("valueOf()")]),e._v("和"),v("code",[e._v("toString()")]),e._v("方法，最后返回"),v("code",[e._v("'foo'")]),e._v("，所以比较结果是"),v("code",[e._v("true")]),e._v("。")]),e._v(" "),v("p",[v("strong",[e._v("（3）undefined 和 null")])]),e._v(" "),v("p",[v("code",[e._v("undefined")]),e._v("和"),v("code",[e._v("null")]),e._v("只有与自身比较，或者互相比较时，才会返回"),v("code",[e._v("true")]),e._v("；与其他类型的值比较时，结果都为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("undefined == undefined // true\nnull == null // true\nundefined == null // true\n\nfalse == null // false\nfalse == undefined // false\n\n0 == null // false\n0 == undefined // false\n")])])]),v("p",[v("strong",[e._v("（4）相等运算符的缺点")])]),e._v(" "),v("p",[e._v("相等运算符隐藏的类型转换，会带来一些违反直觉的结果。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("0 == ''             // true\n0 == '0'            // true\n\n2 == true           // false\n2 == false          // false\n\nfalse == 'false'    // false\nfalse == '0'        // true\n\nfalse == undefined  // false\nfalse == null       // false\nnull == undefined   // true\n\n' \\t\\r\\n ' == 0     // true\n")])])]),v("p",[e._v("上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（"),v("code",[e._v("==")]),e._v("），最好只使用严格相等运算符（"),v("code",[e._v("===")]),e._v("）。")]),e._v(" "),v("h2",{attrs:{id:"不相等运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不相等运算符"}},[e._v("#")]),e._v(" 不相等运算符")]),e._v(" "),v("p",[e._v("相等运算符有一个对应的“不相等运算符”（"),v("code",[e._v("!=")]),e._v("），它的算法就是先求相等运算符的结果，然后返回相反值。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("1 != '1' // false\n\n// 等同于\n!(1 == '1')\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);