(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{477:function(a,t,s){a.exports=s.p+"assets/img/image-20210630223720624.d98977d2.png"},478:function(a,t,s){a.exports=s.p+"assets/img/image-20210630231414587.f5a4509a.png"},539:function(a,t,s){"use strict";s.r(t);var e=s(20),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"_8-包和接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-包和接口"}},[a._v("#")]),a._v(" 8 包和接口")]),a._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#包"}},[a._v("包")]),e("ul",[e("li",[e("a",{attrs:{href:"#包和成员访问"}},[a._v("包和成员访问")])])])]),e("li",[e("a",{attrs:{href:"#接口"}},[a._v("接口")]),e("ul",[e("li",[e("a",{attrs:{href:"#实现接口"}},[a._v("实现接口")])]),e("li",[e("a",{attrs:{href:"#接口中的变量"}},[a._v("接口中的变量")])]),e("li",[e("a",{attrs:{href:"#接口继承"}},[a._v("接口继承")])]),e("li",[e("a",{attrs:{href:"#默认接口方法"}},[a._v("默认接口方法")]),e("ul",[e("li",[e("a",{attrs:{href:"#默认方法基础"}},[a._v("默认方法基础")])])])]),e("li",[e("a",{attrs:{href:"#多继承问题"}},[a._v("多继承问题")])]),e("li",[e("a",{attrs:{href:"#使用静态方法"}},[a._v("使用静态方法")])]),e("li",[e("a",{attrs:{href:"#私有方法"}},[a._v("私有方法")])])])])])]),e("p"),a._v(" "),e("p",[a._v("包: 将相关的类组合在一起。有助于代码组织，并提供了另一种层面的封装。")]),a._v(" "),e("p",[a._v("接口: 定义一些列实现类要实现的方法。指定一个类要做什么，而不是如何做。")]),a._v(" "),e("h2",{attrs:{id:"包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#包"}},[a._v("#")]),a._v(" 包")]),a._v(" "),e("p",[a._v("包的两个目的:")]),a._v(" "),e("ul",[e("li",[a._v("一个程序的相关的部分组织在一起，形成一个单元。定义在包中的类必须通过包名才能访问。因此包提供了一种命名类的方法")]),a._v(" "),e("li",[a._v("包可以在Java的访问控制机制中起作用。在一个包内定义的类可以成为该包的私有类，而不能被包外的代码访问。")])]),a._v(" "),e("h3",{attrs:{id:"包和成员访问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#包和成员访问"}},[a._v("#")]),a._v(" 包和成员访问")]),a._v(" "),e("p",[e("img",{attrs:{src:s(477),alt:"image-20210630223720624"}})]),a._v(" "),e("h2",{attrs:{id:"接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[a._v("#")]),a._v(" 接口")]),a._v(" "),e("p",[a._v("JDK8之前，接口中只能定义抽象方法。JDK8中，接口中可以定义默认实现方法。")]),a._v(" "),e("p",[a._v("JDK9中，还支持静态接口方法 和 private方法。")]),a._v(" "),e("p",[a._v("定义接口的一般形式:")]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[a._v("access "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" name "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n   ret"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("type method"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("name1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("param"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   ret"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("type method"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("name2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("param"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   type var1 "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   type var2 "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ...")]),a._v("\n   ret"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("type method"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("nameN")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("param"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   type varN "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),e("p",[a._v("接口中，方法默认修饰符是public；变量默认修饰符是 public final static，并且必须被初始化，即它们本质上是常量。")]),a._v(" "),e("h3",{attrs:{id:"实现接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现接口"}},[a._v("#")]),a._v(" 实现接口")]),a._v(" "),e("p",[a._v("实现接口的一般形式:")]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" classname "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" superclass "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n   "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// class-body")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),e("p",[a._v("实现接口的方法，必须要是public，应为接口中的方法默认是public的。")]),a._v(" "),e("blockquote",[e("p",[a._v("如果一个类没有完全实现接口中的方法，那么这个类必须要被定义为抽象类")])]),a._v(" "),e("h3",{attrs:{id:"接口中的变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口中的变量"}},[a._v("#")]),a._v(" 接口中的变量")]),a._v(" "),e("p",[a._v("接口中变量默认修饰符是 public final static。")]),a._v(" "),e("p",[a._v("大部分程序中需要定义常量，其中一种方式就是使用接口来定义。但使用接口来定义常量是由争议的，这里只是说明接口可以实现此种功能。")]),a._v(" "),e("h3",{attrs:{id:"接口继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口继承"}},[a._v("#")]),a._v(" 接口继承")]),a._v(" "),e("p",[a._v("一个类要实现一个接口，必须实现该接口继承链上的所有方法。")]),a._v(" "),e("h3",{attrs:{id:"默认接口方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#默认接口方法"}},[a._v("#")]),a._v(" 默认接口方法")]),a._v(" "),e("p",[a._v("JDK8中，接口中可以添加默认实现的方法——default method。")]),a._v(" "),e("p",[a._v("默认方法出现的主要动机是:  在对一个接口进行扩展是，不会破坏已有的实现类。 如果没有默认方法，那么对一个接口进行扩展，其说有的实现类都需要实现扩展的方法，这样会破坏已有的实现类。")]),a._v(" "),e("p",[a._v("默认方法的另一个动机是希望在一个接口中指定一些方法，这些方法基本上是可选的，取决于接口的使用方式")]),a._v(" "),e("p",[a._v("需要指出的是，增加默认方法并没有改变接口的一个关键原则：一个接口仍然不能有实例变量。因此，接口和类之间的不同是，类可以维护状态信息，而接口不行。此外，接口也不能创建实例，它只能被类实现。")]),a._v(" "),e("h4",{attrs:{id:"默认方法基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#默认方法基础"}},[a._v("#")]),a._v(" 默认方法基础")]),a._v(" "),e("p",[a._v("使用关键字 default 定义")]),a._v(" "),e("p",[e("img",{attrs:{src:s(478),alt:"image-20210630231414587"}})]),a._v(" "),e("h3",{attrs:{id:"多继承问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多继承问题"}},[a._v("#")]),a._v(" 多继承问题")]),a._v(" "),e("p",[a._v("例如，一个类实现了两个个接口，如果这些接口中的每一个都提供默认方法，那么有些行为就会从这两个接口中继承。因此，在有限的范围内，默认方法确实支持行为的多重继承。那么，在这种情况下，会发生名称冲突吗？")]),a._v(" "),e("p",[a._v("如有两个接口，Alpha 和 Beta ，它们被MyClass类实现。如果 Alpha 和 Beta都有一个叫做 reset( ) 的默认方法，MyClass类会使用哪个接口的方法？ 或者，如果Beta继承Alpha，哪个默认方法会被使用？或者，如果MyClass自己也实现了默认方法，会怎么样？为了处理这种情况，Java定义了一些列规则来解决冲突。")]),a._v(" "),e("p",[a._v("首先，类实现优先于接口的默认实现。因此，如果MyClass提供了实现，那么就会使用MyClass的方法。此时，这两个接口的默认方法都被MyClass覆盖。")]),a._v(" "),e("p",[a._v("其次，如果一个类实现了两个有相同默认方法的接口，如果类没有覆盖此方法，那么会出错。按上面的例子，如果MyClass实现了Alpha 和 Beta接口，但是没有重写 reset()方法，那么就会报错。")]),a._v(" "),e("p",[a._v("如果一个接口继承另一个，它们都定义了相同的默认方法，继承的接口的默认方法的优先级较高。按上面的例子，如果Beta 继承 Alpha，那么Beta的reset()方法会被使用。")]),a._v(" "),e("p",[a._v("可以通过super的新的形式，来显示的访问默认实现:")]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("InterfaceName")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("super")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("methodName")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),e("p",[a._v("例如，如果Beta想要访问Alpha的reset()方法，可以使用:")]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Alpha")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("super")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("reset")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),e("h3",{attrs:{id:"使用静态方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用静态方法"}},[a._v("#")]),a._v(" 使用静态方法")]),a._v(" "),e("p",[a._v("JDK8中，可以在接口中添加一个或多个静态方法。")]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("InterfaceName")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("staticMethodName\n")])])]),e("p",[a._v("注意，静态接口方法不会被实现类或子接口继承")]),a._v(" "),e("h3",{attrs:{id:"私有方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#私有方法"}},[a._v("#")]),a._v(" 私有方法")]),a._v(" "),e("p",[a._v("JDK9中，可以在接口中添加私有方法，私有方法只能被接口中的默认方法或其他私有方法调用")]),a._v(" "),e("p",[a._v("私有方法的主要用处是对公共代码片段进行抽取，避免重复代码。")])])}),[],!1,null,null,null);t.default=r.exports}}]);