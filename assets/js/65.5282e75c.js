(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{560:function(a,e,v){"use strict";v.r(e);var _=v(20),t=Object(_.a)({},(function(){var a=this,e=a.$createElement,v=a._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"二进制位运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制位运算符"}},[a._v("#")]),a._v(" 二进制位运算符")]),a._v(" "),v("p",[a._v("二进制位运算符用于直接对二进制位进行计算，一共有7个。")]),a._v(" "),v("ul",[v("li",[v("strong",[a._v("二进制或运算符")]),a._v("（or）：符号为"),v("code",[a._v("|")]),a._v("，表示若两个二进制位都为"),v("code",[a._v("0")]),a._v("，则结果为"),v("code",[a._v("0")]),a._v("，否则为"),v("code",[a._v("1")]),a._v("。")]),a._v(" "),v("li",[v("strong",[a._v("二进制与运算符")]),a._v("（and）：符号为"),v("code",[a._v("&")]),a._v("，表示若两个二进制位都为1，则结果为1，否则为0。")]),a._v(" "),v("li",[v("strong",[a._v("二进制否运算符")]),a._v("（not）：符号为"),v("code",[a._v("~")]),a._v("，表示对一个二进制位取反。")]),a._v(" "),v("li",[v("strong",[a._v("异或运算符")]),a._v("（xor）：符号为"),v("code",[a._v("^")]),a._v("，表示若两个二进制位不相同，则结果为1，否则为0。")]),a._v(" "),v("li",[v("strong",[a._v("左移运算符")]),a._v("（left shift）：符号为"),v("code",[a._v("<<")]),a._v("，详见下文解释。")]),a._v(" "),v("li",[v("strong",[a._v("右移运算符")]),a._v("（right shift）：符号为"),v("code",[a._v(">>")]),a._v("，详见下文解释。")]),a._v(" "),v("li",[v("strong",[a._v("头部补零的右移运算符")]),a._v("（zero filled right shift）：符号为"),v("code",[a._v(">>>")]),a._v("，详见下文解释。")])]),a._v(" "),v("p",[a._v("这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。")]),a._v(" "),v("p",[a._v("有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("i = i | 0;\n")])])]),v("p",[a._v("上面这行代码的意思，就是将"),v("code",[a._v("i")]),a._v("（不管是整数或小数）转为32位整数。")]),a._v(" "),v("p",[a._v("利用这个特性，可以写出一个函数，将任意数值转为32位整数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function toInt32(x) {\n  return x | 0;\n}\n")])])]),v("p",[a._v("上面这个函数将任意值与"),v("code",[a._v("0")]),a._v("进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("toInt32(1.001) // 1\ntoInt32(1.999) // 1\ntoInt32(1) // 1\ntoInt32(-1) // -1\ntoInt32(Math.pow(2, 32) + 1) // 1\ntoInt32(Math.pow(2, 32) - 1) // -1\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("toInt32")]),a._v("可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于2的32次方的整数，大于32位的数位都会被舍去。")]),a._v(" "),v("h2",{attrs:{id:"二进制或运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制或运算符"}},[a._v("#")]),a._v(" 二进制或运算符")]),a._v(" "),v("p",[a._v("二进制或运算符（"),v("code",[a._v("|")]),a._v("）逐位比较两个运算子，两个二进制位之中只要有一个为"),v("code",[a._v("1")]),a._v("，就返回"),v("code",[a._v("1")]),a._v("，否则返回"),v("code",[a._v("0")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0 | 3 // 3\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("0")]),a._v("和"),v("code",[a._v("3")]),a._v("的二进制形式分别是"),v("code",[a._v("00")]),a._v("和"),v("code",[a._v("11")]),a._v("，所以进行二进制或运算会得到"),v("code",[a._v("11")]),a._v("（即"),v("code",[a._v("3")]),a._v("）。")]),a._v(" "),v("p",[a._v("位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与"),v("code",[a._v("0")]),a._v("进行二进制或运算，等同于对该数去除小数部分，即取整数位。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("2.9 | 0 // 2\n-2.9 | 0 // -2\n")])])]),v("p",[a._v("需要注意的是，这种取整方法不适用超过32位整数最大值"),v("code",[a._v("2147483647")]),a._v("的数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("2147483649.4 | 0;\n// -2147483647\n")])])]),v("h2",{attrs:{id:"二进制与运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制与运算符"}},[a._v("#")]),a._v(" 二进制与运算符")]),a._v(" "),v("p",[a._v("二进制与运算符（"),v("code",[a._v("&")]),a._v("）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为"),v("code",[a._v("0")]),a._v("，就返回"),v("code",[a._v("0")]),a._v("，否则返回"),v("code",[a._v("1")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0 & 3 // 0\n")])])]),v("p",[a._v("上面代码中，0（二进制"),v("code",[a._v("00")]),a._v("）和3（二进制"),v("code",[a._v("11")]),a._v("）进行二进制与运算会得到"),v("code",[a._v("00")]),a._v("（即"),v("code",[a._v("0")]),a._v("）。")]),a._v(" "),v("h2",{attrs:{id:"二进制否运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制否运算符"}},[a._v("#")]),a._v(" 二进制否运算符")]),a._v(" "),v("p",[a._v("二进制否运算符（"),v("code",[a._v("~")]),a._v("）将每个二进制位都变为相反值（"),v("code",[a._v("0")]),a._v("变为"),v("code",[a._v("1")]),a._v("，"),v("code",[a._v("1")]),a._v("变为"),v("code",[a._v("0")]),a._v("）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("~ 3 // -4\n")])])]),v("p",[a._v("上面表达式对"),v("code",[a._v("3")]),a._v("进行二进制否运算，得到"),v("code",[a._v("-4")]),a._v("。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算。")]),a._v(" "),v("p",[v("code",[a._v("3")]),a._v("的32位整数形式是"),v("code",[a._v("00000000000000000000000000000011")]),a._v("，二进制否运算以后得到"),v("code",[a._v("11111111111111111111111111111100")]),a._v("。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于"),v("code",[a._v("11111111111111111111111111111011")]),a._v("，再取一次反得到"),v("code",[a._v("00000000000000000000000000000100")]),a._v("，再加上负号就是"),v("code",[a._v("-4")]),a._v("。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("~ -3 // 2\n")])])]),v("p",[a._v("上面表达式可以这样算，"),v("code",[a._v("-3")]),a._v("的取反值等于"),v("code",[a._v("-1")]),a._v("减去"),v("code",[a._v("-3")]),a._v("，结果为"),v("code",[a._v("2")]),a._v("。")]),a._v(" "),v("p",[a._v("对一个整数连续两次二进制否运算，得到它自身。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("~~3 // 3\n")])])]),v("p",[a._v("所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("~~2.9 // 2\n~~47.11 // 47\n~~1.9999 // 1\n~~3 // 3\n")])])]),v("p",[a._v("使用二进制否运算取整，是所有取整方法中最快的一种。")]),a._v(" "),v("p",[a._v("对字符串进行二进制否运算，JavaScript 引擎会先调用"),v("code",[a._v("Number")]),a._v("函数，将字符串转为数值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 相当于~Number('011')\n~'011'  // -12\n\n// 相当于~Number('42 cats')\n~'42 cats' // -1\n\n// 相当于~Number('0xcafebabe')\n~'0xcafebabe' // 889275713\n\n// 相当于~Number('deadbeef')\n~'deadbeef' // -1\n")])])]),v("p",[v("code",[a._v("Number")]),a._v("函数将字符串转为数值的规则，参见《数据的类型转换》一章。")]),a._v(" "),v("p",[a._v("对于其他类型的值，二进制否运算也是先用"),v("code",[a._v("Number")]),a._v("转为数值，然后再进行处理。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 相当于 ~Number([])\n~[] // -1\n\n// 相当于 ~Number(NaN)\n~NaN // -1\n\n// 相当于 ~Number(null)\n~null // -1\n")])])]),v("h2",{attrs:{id:"异或运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异或运算符"}},[a._v("#")]),a._v(" 异或运算符")]),a._v(" "),v("p",[a._v("异或运算（"),v("code",[a._v("^")]),a._v("）在两个二进制位不同时返回"),v("code",[a._v("1")]),a._v("，相同时返回"),v("code",[a._v("0")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0 ^ 3 // 3\n")])])]),v("p",[a._v("上面表达式中，"),v("code",[a._v("0")]),a._v("（二进制"),v("code",[a._v("00")]),a._v("）与"),v("code",[a._v("3")]),a._v("（二进制"),v("code",[a._v("11")]),a._v("）进行异或运算，它们每一个二进制位都不同，所以得到"),v("code",[a._v("11")]),a._v("（即"),v("code",[a._v("3")]),a._v("）。")]),a._v(" "),v("p",[a._v("“异或运算”有一个特殊运用，连续对两个数"),v("code",[a._v("a")]),a._v("和"),v("code",[a._v("b")]),a._v("进行三次异或运算，"),v("code",[a._v("a^=b; b^=a; a^=b;")]),a._v("，可以"),v("a",{attrs:{href:"https://en.wikipedia.org/wiki/XOR_swap_algorithm",target:"_blank",rel:"noopener noreferrer"}},[a._v("互换"),v("OutboundLink")],1),a._v("它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = 10;\nvar b = 99;\n\na ^= b, b ^= a, a ^= b;\n\na // 99\nb // 10\n")])])]),v("p",[a._v("这是互换两个变量的值的最快方法。")]),a._v(" "),v("p",[a._v("异或运算也可以用来取整。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("12.9 ^ 0 // 12\n")])])]),v("h2",{attrs:{id:"左移运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#左移运算符"}},[a._v("#")]),a._v(" 左移运算符")]),a._v(" "),v("p",[a._v("左移运算符（"),v("code",[a._v("<<")]),a._v("）表示将一个数的二进制值向左移动指定的位数，尾部补"),v("code",[a._v("0")]),a._v("，即乘以"),v("code",[a._v("2")]),a._v("的指定次方。向左移动的时候，最高位的符号位是一起移动的。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 4 的二进制形式为100，\n// 左移一位为1000（即十进制的8）\n// 相当于乘以2的1次方\n4 << 1\n// 8\n\n-4 << 1\n// -8\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("-4")]),a._v("左移一位得到"),v("code",[a._v("-8")]),a._v("，是因为"),v("code",[a._v("-4")]),a._v("的二进制形式是"),v("code",[a._v("11111111111111111111111111111100")]),a._v("，左移一位后得到"),v("code",[a._v("11111111111111111111111111111000")]),a._v("，该数转为十进制（减去1后取反，再加上负号）即为"),v("code",[a._v("-8")]),a._v("。")]),a._v(" "),v("p",[a._v("如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("13.5 << 0\n// 13\n\n-13.5 << 0\n// -13\n")])])]),v("p",[a._v("左移运算符用于二进制数值非常方便。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var color = {r: 186, g: 218, b: 85};\n\n// RGB to HEX\n// (1 << 24)的作用为保证结果是6位数\nvar rgb2hex = function(r, g, b) {\n  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b)\n    .toString(16) // 先转成十六进制，然后返回字符串\n    .substr(1);   // 去除字符串的最高位，返回后面六个字符串\n}\n\nrgb2hex(color.r, color.g, color.b)\n// \"#bada55\"\n")])])]),v("p",[a._v("上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。")]),a._v(" "),v("h2",{attrs:{id:"右移运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#右移运算符"}},[a._v("#")]),a._v(" 右移运算符")]),a._v(" "),v("p",[a._v("右移运算符（"),v("code",[a._v(">>")]),a._v("）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补"),v("code",[a._v("0")]),a._v("；如果是负数，头部全部补"),v("code",[a._v("1")]),a._v("。右移运算符基本上相当于除以"),v("code",[a._v("2")]),a._v("的指定次方（最高位即符号位参与移动）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("4 >> 1\n// 2\n/*\n// 因为4的二进制形式为 00000000000000000000000000000100，\n// 右移一位得到 00000000000000000000000000000010，\n// 即为十进制的2\n*/\n\n-4 >> 1\n// -2\n/*\n// 因为-4的二进制形式为 11111111111111111111111111111100，\n// 右移一位，头部补1，得到 11111111111111111111111111111110,\n// 即为十进制的-2\n*/\n")])])]),v("p",[a._v("右移运算可以模拟 2 的整除运算。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("5 >> 1\n// 2\n// 相当于 5 / 2 = 2\n\n21 >> 2\n// 5\n// 相当于 21 / 4 = 5\n\n21 >> 3\n// 2\n// 相当于 21 / 8 = 2\n\n21 >> 4\n// 1\n// 相当于 21 / 16 = 1\n")])])]),v("h2",{attrs:{id:"头部补零的右移运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#头部补零的右移运算符"}},[a._v("#")]),a._v(" 头部补零的右移运算符")]),a._v(" "),v("p",[a._v("头部补零的右移运算符（"),v("code",[a._v(">>>")]),a._v("）与右移运算符（"),v("code",[a._v(">>")]),a._v("）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（"),v("code",[a._v(">>")]),a._v("）完全一致，区别主要在于负数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("4 >>> 1\n// 2\n\n-4 >>> 1\n// 2147483646\n/*\n// 因为-4的二进制形式为11111111111111111111111111111100，\n// 带符号位的右移一位，得到01111111111111111111111111111110，\n// 即为十进制的2147483646。\n*/\n")])])]),v("p",[a._v("这个运算实际上将一个值转为32位无符号整数。")]),a._v(" "),v("p",[a._v("查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("-1 >>> 0 // 4294967295\n")])])]),v("p",[a._v("上面代码表示，"),v("code",[a._v("-1")]),a._v("作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即"),v("code",[a._v("(2^32)-1")]),a._v("，等于"),v("code",[a._v("11111111111111111111111111111111")]),a._v("）。")]),a._v(" "),v("h2",{attrs:{id:"开关作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#开关作用"}},[a._v("#")]),a._v(" 开关作用")]),a._v(" "),v("p",[a._v("位运算符可以用作设置对象属性的开关。")]),a._v(" "),v("p",[a._v("假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var FLAG_A = 1; // 0001\nvar FLAG_B = 2; // 0010\nvar FLAG_C = 4; // 0100\nvar FLAG_D = 8; // 1000\n")])])]),v("p",[a._v("上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。")]),a._v(" "),v("p",[a._v("然后，就可以用二进制与运算，检查当前设置是否打开了指定开关。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var flags = 5; // 二进制的0101\n\nif (flags & FLAG_C) {\n  // ...\n}\n// 0101 & 0100 => 0100 => true\n")])])]),v("p",[a._v("上面代码检验是否打开了开关"),v("code",[a._v("C")]),a._v("。如果打开，会返回"),v("code",[a._v("true")]),a._v("，否则返回"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("p",[a._v("现在假设需要打开"),v("code",[a._v("A")]),a._v("、"),v("code",[a._v("B")]),a._v("、"),v("code",[a._v("D")]),a._v("三个开关，我们可以构造一个掩码变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var mask = FLAG_A | FLAG_B | FLAG_D;\n// 0001 | 0010 | 1000 => 1011\n")])])]),v("p",[a._v("上面代码对"),v("code",[a._v("A")]),a._v("、"),v("code",[a._v("B")]),a._v("、"),v("code",[a._v("D")]),a._v("三个变量进行二进制或运算，得到掩码值为二进制的"),v("code",[a._v("1011")]),a._v("。")]),a._v(" "),v("p",[a._v("有了掩码，二进制或运算可以确保打开指定的开关。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("flags = flags | mask;\n")])])]),v("p",[a._v("上面代码中，计算后得到的"),v("code",[a._v("flags")]),a._v("变量，代表三个开关的二进制位都打开了。")]),a._v(" "),v("p",[a._v("二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("flags = flags & mask;\n")])])]),v("p",[a._v("异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("flags = flags ^ mask;\n")])])]),v("p",[a._v("二进制否运算可以翻转当前设置，即原设置为"),v("code",[a._v("0")]),a._v("，运算后变为"),v("code",[a._v("1")]),a._v("；原设置为"),v("code",[a._v("1")]),a._v("，运算后变为"),v("code",[a._v("0")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("flags = ~flags;\n")])])]),v("h2",{attrs:{id:"参考链接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[a._v("#")]),a._v(" 参考链接")]),a._v(" "),v("ul",[v("li",[a._v("Michal Budzynski, "),v("a",{attrs:{href:"https://michalbe.blogspot.co.uk/2013/03/javascript-less-known-parts-bitwise.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript: The less known parts. Bitwise Operators"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Axel Rauschmayer, "),v("a",{attrs:{href:"http://www.2ality.com/2013/06/basic-javascript.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Basic JavaScript for the impatient programmer"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Mozilla Developer Network, "),v("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators",target:"_blank",rel:"noopener noreferrer"}},[a._v("Bitwise Operators"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=t.exports}}]);